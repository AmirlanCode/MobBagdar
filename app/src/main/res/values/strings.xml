<resources>
    <string name="app_name">JavaKaz</string>

    <string-array name="razdely">
        <item name="First">"Java бастауыш"</item>
        <item name="Second">"Java орташа деңгей"</item>
        <item name="Third">"Java pro"</item>

    </string-array>

    <string name="history_java">Java-ның тарихы</string>
    <string name="types">Деректер типтері</string>
    <string name="operator">Java операторлары</string>
    <string name="condition_operators">Таңдау және итерация></string>
    <string name="cyclers">Кейінгі шартты және алдыңғы шартты интерациялық циклдер,
        есептегіштермен циклдер</string>

    <string name="history_java_info">Java программалық платформасы 90-жылдардың басында заманауи программалау тілі мен тізбекті ортадан бөлек тізбекті алу үшін әзірленген. Ол үшін кроссплатформа программалау қажет болды, өйткені кез келген платформаға (тіпті кофемашинаға) тек тізбекті орта қажет болды.
Java технологиясының серпіні 90-жылдардың аяғында Интернетке байланысты
болды. Java арқасында және тиісті әдістермен (апплеттер сияқты), веб-программалау
алға қарай қарыштап дамыды. Қазіргі таңда Java программалары барлық салаларда қолданылады: тек веб-программалауда ғана емес, сонымен қатар десктопты
қосымшалар ретінде, мобильді есептеулерде (Mobile Computing) немесе енгізілген
жүйелер ретінде (Embedded Systems) қолданылады.</string>
    <string name="types_info">Java программаларында айнымалылар мәндерді сақтау үшін қызмет етеді. Осылайша,
олар кез келген мән үшін толтырғыш символы болып табылады. Мысалы, пайыздарды
есептеу үшін есептеу нәтижесін сақтау үшін айнымалыны пайдалануға болады. Айнымалылардың жарамды идентификатор болуы тиіс аты бар.
Кейбір программалау тілдерінде (мысалы, BASIC) кез келген мәндерді сақтай алатын
айнымалылар бар (бүтін мәндер, жүзбелі үтірлі сандар, символдар жолдары және т.б.).
Java-да мәндердің қай типін айнымалы сақтау керектігін алдын ала анықтау қажет. Бұл
ретте, бұл айнымалы деректер типі туралы. Деректер типі мәндердің ауқымы мен түрін дәл
анықтайды. Сондай-ақ, айнымалыларды анықтау аймақтары бар. Кейбір айнымалылар
жергілікті әрекет етеді (яғни, орнымен шектелген) - мысалы, тек бір әдісте ғана. Кейбір
айнымалылар бірнеше әдістер үшін жарамды болуы мүмкін. Бұл айнымалылар тиісті
сыныпта құрылады. Алайда, іс-әрекет туралы толық түсінік тек сынып тұжырымдамасын
өңдегеннен кейін ғана алуға болады. Бұған дейін айнымалылар негізінен main әдісі
бойынша қарастырылады.</string>
    <string name="operator_info">Арифметикалық операторлар
4.1.1 Қарапайым деректер типтері және олардың арифметикалық операторлары
Бұрын біз әртүрлі деректер типтеріне арналған арифметикалық операторлар (негізгі
арифметикалық Операторлар деп аталатын) туралы айттық. Операторлар біз математика
сабағында үйренгендей қолданылады. Алайда, әртүрлі деректер типін ажырату керек,
себебі операторлар деректер типіне байланысты әртүрлі.
Жылжымалы үтірлі сандардың түрі бойынша деректер типі (float және double):
Негізгі арифметикалық операторлар әдеттегідей қолданылады. Осы үлгідегі санды
жинауға, шегеруге, көбейтіп және бөлуге болады. Операциялардың нәтижесі – жылжымалы
үтірдің түрі бойынша сандар болып табылады.
Мысал:
float a = 1.2f;
float b = 10.45f;
float c;
c = a + b;
c = a / b;
    Толық сандардың түрі бойынша деректер типі (byte, short, int, long):
Негізгі арифметикалық операторлар әдеттегідей қолданылады. Осы үлгідегі санды
жинауға, шегеруге, көбейтіп және бөлуге болады. Операциялардың нәтижесі жылжымалы
үтір түрі бойынша сандар болып табылады.
Мысал:
int x = 1;
int y = 2;
int z;
z = x + y;
z = x / y;
        Инкременттегі және декременттегі операторлар
Программалау кезінде айнымалы мәнін жиі 1-ге көбейту немесе азайту қажет болады,
мысалы, белгілі бір процестерді немесе операцияларды есептейтін айнымалылар. Ол
үшін 1 айнымалысын ұлғайтатын немесе азайтатын арнайы операторлар бар. Бұл „++“
инкрементінің операторы және „—“ декрементінің операторы.
НАЗАР АУДАРЫҢЫЗ:
Операторлардың позициясы маңызды. Префикс және постфикс жазбасы бар. Бұл
дегеніміз, оператор өзгеріске дейін және кейін жазылған. Бұл төмендегі мысалдарда
көрсетілгендей әсер етеді:
Постфикс жазбасы
int x = 10;
System.out.println(x++);
System.out.println(x);
    </string>
    <string name="condition_operators_info">If операторының көмегімен жеке таңдау
Java-да таңдау мүмкіндігі (селекция) If кілт сөзі арқылы іске асырылады. If операторы
бұл жалғыз таңдау, өйткені шартты орындау кезінде тек бір немесе бірнеше команда ғана
орындалады. Егер шарт орындалмаса, онда ештеңе болмайды.
Java-дағы синтаксис:
 Оператор if ( шарт );
        4 If және if-else операторларының көмегімен тармақтау
Әрине, таңдау операторынан кейін қайтадан таңдау болуы мүмкін, өйткені таңдау өзі
әрекет ететін команда ретінде өзгеше емес. Тармақ кез келген тереңдікте болуы мүмкін. Тым
болмағанда, тармақталу тереңдігі бір кездері жады аймағының мәселесімен шектелуі мүмкін.
Мысал:
int a = 10;
int b = 20;
int c = 1;
if ( b > 10 )
if ( c != 0) System.out.println("барлық шарт. орындалды ");
 else System.out.println("3-ші шарт орындалмады ");
else System.out.println("2-ші шарт орындалмады ");
else System.out.println("1-ші шарт орындалмады ");
    </string>
    <string name="cyclers_info"> For циклі
For циклі есептегішпен цикл деп аталады. Ереже бойынша, айнымалы өз мәнін бастапқы
берілген мәннен кейбір қадаммен соңғы мәнге дейін өзгертеді.
Java-дағы синтаксис:
for (инициализация; шарт; қадам) команда;
Әрине, сондай-ақ жарамды:
for (инициализация; шарт; қадам) {
команда _1;
команда _2;
:
команда _N;
{

    for (int i = 10; i>0 ; System.out.println(i—)) ;
Бұл цикл айнымалы i мәнін 10-нан 1-ге дейін есептейді және тиісті мәндерді береді. Бұл ретте қадамдық бөлікте қадамдық оператор болмайды, ал бір мезгілде декременттей отырып, i айнымалысын экранға шығарады. Цикл денесінде операторлар жоқ.
Ескертпе:
for айнымалы циклі, ереже бойынша, инициализация бөлігінде жарияланады
және инициализацияланады. Осылайша, бұл for айнымалы цикл (жергілікті әрекет)
шеңберінде ғана жарамды. for циклінен кейін айнымалыны пайдалану болмайды.
for (int i = 1; i = 10; i = i + 1)
 System.out.println("циклдің мәні: " + i);
    </string>

    <string name="java_classes">Java тіліндегі кластар ұғымы</string>
    <string name="java_OOP">Java тілінде мұрагерлік</string>
    <string name="polymorphism">Java тілінде мұрагерлік</string>
    <string name="abstract_classes">Абстрактілі базалық кластар</string>
    <string name="interfaces">Java интерфейстері</string>


    <string name="java_classes_info">Мұрагерлік концепті ОББ-дағы орталық болып табылады. Біріншіден, программалау
тілінде „шынайы“ әлемдегі жағдайды мұрагерлік көмегі арқылы қолдану оңай, екіншіден,
қазір уақыттағы қолданыстағы программа кодын қайта қолдануға болады (класс түрінде).
Осы уақытқа дейінгі бар және тексерілген кодтардың арқасында программалық қамтамасыз
етуді әзірлеудің үлкен тиімділігі мен сенімділігіне қол жеткізіледі. Мұрагерлік туралы сөз
жүргенде, ол нақты реляция туралы болады.

    Базалық класс конструкторларын айқын шақыру
Базалық кластың стандартты конструкторы анық емес түрде шақырылады жоғарыдағы
мысалдан анық көруге болады. Кейбір жағдайларда, ең алдымен, бірнеше конструктор
болған кезде, базалық кластың конструкторын анық шақырудың мүмкіндігінің болғаны
дұрыс. Бұл төмендегі мысалда көрсетілгендей super кілт сөзі көмегі арқылы жүреді:
Мысал:
class тұлға {
private String аты;
public тұлға() {
 аты = "БОС";
 }
public тұлға(String атыПараметр) {
 аты = атыПараметр;
 }
public String Атыненгіз() {
 return аты;
 }
 }
class клиент extends тұлға {
private int IDклиента;
public клиент()
 super();
 клиент ID = 0
}
public клиент(String атыПараметр, int IDклиентПараметрі) {
Конструктор параметрін шақыру
super(атыПараметр);
IDклиента = клиент
}
public void шығару() {
System.out.println("аты: " + Атыненгіз());
System.out.println("клиентID-і: " + клиентID-і);
}
}
public class мұрагерлік {
public static void main(String[] args) {
 клиент бірКлиент = new клиент();
 клиент екіншіКлиент = new клиент("Майер", 123);
 екіншіКлиент.шығару();
 }
}
    </string>
    <string name="java_incap">Инкапсуляция клиенттен ақпаратты жасыру механизмі болып табылады. Ақпарат деректер немесе іске асыру немесе алгоритм болуы мүмкін.Біз қолжетімділік модификаторларын қолдана отырып қол жеткізіңіз.</string>
    <string name="polymorphism_info">Тек полиморфизмді пайдаланатын программалау тілі объектілі-бағытталған деп аталуы
мүмкін. Әйтпесе, бұл – объектілерде негізделген жай программалау тілі. Полиморфизмнің
жалпы мәні программаны орындау кезінде сілтеме әртүрлі объектілерге көрсетуі мүмкін
және, дегенмен, объектінің дұрыс әдістерін осы сілтеменің көмегімен шақыруға болады. Бұл
түсініктеме сәл күрделі болып көрінеді, енді осы нақты мысалдарда түсіндірілуі керек. Бұл
үшін java.lang.Object (барлық кластардың негізі) класының бірінші кезеңінде мұраға
алу иерархиясы шеңберінде сілтемелер беру талқыланады. Болашақта полиморфизмнің
мәнін егжей-тегжейлі түсіндіруге болады.
</string>
    <string name="abstract_classes_info">Абстрактілі базалық кластар
Абстрактілі базалық класс басқа кластар үшін осы кластан объектіні инстанциялауға
мүмкіндігі жоқ негіз болуы тиіс. Абстрактілі кластар мұрагерлік иерархиясы үшін негіз қажет
болған кезде мағынасы бар, бірақ негізгі сыныптан мағыналық объектілер анықталуы
мүмкін емес және болмауы тиіс.</string>
    <string name="interfaces_info">Интерфейс принципі (түйісу орны) абстрактілі базалық кластар ұғымымен көптеген
ортақтығы бар. Интерфейс класс сияқты көрінеді, бірақ ешқандай орындалусыз. Интерфейс
тек қандай әдістерді қолдану керектігін анықтайды. Интерфейсті орындайтын класс, сондайақ әдістерді сипаттауы керек. Класс шексіз интерфейстерді орындай алады.</string>


</resources>